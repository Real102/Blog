# 笔记

## 2022 年 2 月 1 日

### 类型断言

类型断言相当于告诉/指定 `TypeScript` 编译器某个值的类型

类型断言好比 `JS` 中的类型转换，但是不进行特殊的数据检查和解构。 它不会在运行时影响，只是在编译阶段起作用。

类型断言的两种方式：

```typescript
// “尖括号”语法
let someValue: any = "this is a string"
let strLength: number = (<string>someValue).length

// as语法
let someValue: any = "this is a string"
let strLength: number = (someValue as string).length
```

两种使用形式是等价的，但在 `TypeScript` 里使用 `JSX` 时，只有 `as` 语法断言是被允许的。

## 2022 年 2 月 2 日

### vuex-class 中使用 module

`vuex` 中使用 `module`，需要指定 `namespaced` 为 `true`

使用 `State` 访问 `module` 中的属性时，需要指定 `namespace`，有以下两种方式引用。前者适合需要多次使用同一个 `module` 的情况

```javascript
import { State, namespace } from "vuex-class"
const userModule = namespace("user")
export default class Home extends Vue {
  @userModule.State userInfo!: IUserInfo
}

// 或
import { State, namespace } from "vuex-class"
export default class Home extends Vue {
  @namespace('user').State userInfo!: IUserInfo
}
```

## 2022 年 2 月 3 日

### Computed Properties In Class-Component

使用 `vue-class-component` 后，已取消了 `computed` 选项，可以通过声明类属性 `getter/setter` 来代替

```javascript
import Vue from "vue"
import Component from "vue-class-component"

@Component
export default class HelloWorld extends Vue {
  firstName = "John"
  lastName = "Doe"

  // Declared as computed property getter
  get name() {
    return this.firstName + " " + this.lastName
  }

  // Declared as computed property setter
  set name(value) {
    const splitted = value.split(" ")
    this.firstName = splitted[0]
    this.lastName = splitted[1] || ""
  }
}
```

## 2022 年 2 月 4 日

### vue-class-component Hooks

使用了 `vue-class-component` 后，仍然可以正常使用 `vue` 选项，但不能在实例上调用它们，并且在声明方法时，避免使用这些保留名称

```javascript
import Vue from "vue"
import Component from "vue-class-component"

@Component
export default class HelloWorld extends Vue {
  // Declare mounted lifecycle hook
  mounted() {
    console.log("mounted")
  }

  // Declare render function
  render() {
    return <div>Hello World!</div>
  }
}
```

## 2022 年 2 月 5 日

### Additional Hooks

使用了 `vue-class-component` 后，如果需要使用如：`beforeRouterEnter` （`Vue Router` 插件） 等 `Vue` 插件提供的额外的方法的话，需要使用 `Component.registerHooks` 去注册这些钩子

```javascript
// class-component-hooks.js
import Component from "vue-class-component"

// Register the router hooks with their names
Component.registerHooks(["beforeRouteEnter", "beforeRouteLeave", "beforeRouteUpdate"])
```

注意在 `main.js` 中的引入位置

```javascript
// main.js
// Make sure to register before importing any components
import "./class-component-hooks"

import Vue from "vue"
import App from "./App"

new Vue({
  el: "#app",
  render: h => h(App)
})
```

之后，就可以正常使用相关方法了
