# 笔记

## 2021 年 12 月 1 日

### 解构赋值

收录了一些结构赋值常用的场景~

文档地址：[ES6 官方文档 🚀](https://es6.ruanyifeng.com/?search=%3F%3F&x=3&y=5#docs/destructuring#%E7%94%A8%E9%80%94)

#### 交换变量的值

```javascript
let x = 1
let y = 2

;[x, y] = [y, x]
```

#### 从函数返回多个值

```javascript
function example() {
  return {
    foo: 1,
    bar: 2
  }
}
let { foo, bar } = example()
// 同返回数组
```

#### 函数参数的定义

```javascript
// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
```

#### 提取 JSON 数据

```javascript
let jsonData = {
  id: 42,
  status: "OK",
  data: [867, 5309]
}

let { id, status, data: number } = jsonData
```

#### 函数参数的默认值

```javascript
jQuery.ajax = function(
  url,
  {
    async = true,
    beforeSend = function() {},
    cache = true,
    complete = function() {},
    crossDomain = false,
    global = true
    // ... more config
  } = {}
) {
  // ... do stuff
}
```

#### 遍历 MAP 结构

```javascript
const map = new Map()
map.set("first", "hello")
map.set("second", "world")

for (let [key, value] of map) {
  console.log(key + " is " + value)
}
```

#### 输入模块的指定方法

```javascript
const { SourceMapConsumer, SourceNode } = require("source-map")
```

## 2021 年 12 月 2 日

### BigInt

号称 ECMAScript 的第八种数据类型。有以下特点

- 必须加上后缀 `n`
- 只用于表示整数
- 不限于各种进制
- 没有位数限制
- 可以使用负号，但不能使用正号（`+`）
- 与普通整数不相等： `42n === 42` 的结果为 `false`
- `typeof` 返回的值为 `BigInt`

可以通过 `BigInt()` 函数将其他类型转换成 `BigInt`

`BigInt` 还包含 `toString()`、`valueOf()`、`toLocaleString()` 等一些[方法 🚀](https://es6.ruanyifeng.com/?search=%3F%3F&x=3&y=5#docs/number#BigInt-%E5%87%BD%E6%95%B0)

## 2021 年 12 月 3 日

缺席...

## 2021 年 12 月 4 日

缺席...

## 2021 年 12 月 5 日

缺席...

## 2021 年 12 月 6 日

### referer === referrer ？

`HTTP` 中的 `referer` 是请求头的一个字段，用于表示这个请求是从哪个来源网页发出的，即可以检查访客从哪里来，也可以用于对付伪造的跨网站请求（csrf）

`referer` 的正确英文是 `referrer`，这是早期 `HTTP` 规范当中存在的拼写错误，后来为了保持向下兼容就将错就错。一般说 `referrer` 指的就是 `document.referrer`，

因引用地址信息 `referer` 可能会带来隐私权问题，不少网页浏览器允许用户设置不要提交这个信息，有些代理服务器和防火墙也会将引用地址信息过滤掉，以避免外部获知非公开的网络地址。因此如果想要保证 referer 信息的上传，可以手动设置一下 meta 头

```html
<meta content="always" name="referrer" />
```

`referer` 不被允许修改，浏览器会提示：`Refused to set unsage header "Referer"`

其他不能修改的请求头如下：

```text
Accept-Charset
Accept-Encoding
Access-Control-Request-Headers
Access-Control-Request-Method
Connection
Content-Length
Cookie
Cookie2
Date
DNT
Expect
Feature-Policy
Host
Keep-Alive
Origin
Proxy-
Sec-
Referer
TE
Trailer
Transfer-Encoding
Upgrade
Via
```

## 2021 年 12 月 7 日

### Content-Security-Policy

作为前端开发，应该都知道浏览器的同源策略：浏览器仅加载同协议、域名及端口的脚本文档。`Content-Security-Policy` 也就是浏览器内容安全策略 `CSP`，其安全模式也是来源于“同源策略”，通过控制脚本/资源的来源来达到保证安全的目的。`CSP` 是一个可以显著降低 `XSS` 攻击的风险和影响的一种防护功能

<!-- 我们可以手动配置 `CSP`，针对各种资源进行来源控制 -->

`CSP` 可通过 `http` 标头（首选且优先级较高，一般在 `nginx` 配置）或 `meta` 标签进行配置，相关可配置资源有如下：

```html
<!-- meta标签使用方式 -->
<meta
  http-equiv="Content-Security-Policy"
  content="default-src https://cdn.example.net; child-src 'none'; object-src 'none'"
/>
```

| name                      | policy                                                 |
| ------------------------- | ------------------------------------------------------ |
| base-uri                  | 限制 `base` 标签内容来源                               |
| child-src                 | 限制 `iframe` 内容来源                                 |
| connect-src               | 限制 `http` 请求地址（`XHR`、`WS`、`EventSource`）     |
| font-src                  | 限制字体文件来源地址                                   |
| form-action               | 限制 `form` 表单提交地址                               |
| frame-ancestors           | 限制被 `iframe` 嵌套的来源地址（不能在 `HTML` 上使用） |
| frame-src                 | 已弃用。请改用 `child-src`                             |
| img-src                   | 限制图片资源地址                                       |
| media-src                 | 限制音视频资源地址                                     |
| object-src                | 限制 `flash` 来源地址（可执行外部 `js` 代码）          |
| plugin-types              | 限制插件来源地址                                       |
| report-uri                | 限制发送报告的地址（不能用于 `meta`）                  |
| script-src                | 限制 `js` 来源地址                                     |
| style-src                 | 限制 `css` 来源地址                                    |
| upgrade-insecure-requests | 指使 `UserAgent` 将 `HTTP` 更改为 `HTTPS`              |

需要针对某一项指令配置多个值时，可以直接添加多个值。注意中间只需要空格隔开。多项指令用 `；` 隔开

```shell
script-src https://host1.com https://host2.com
```

如果不针对某一项指令设置值时，默认以 \* 作为有效来源（即相当于无限制）。可以使用 `default-src` 指令替换默认行为，但需要注意，`default-src` 主要针对 `-src` 类指令的来源进行限制

指令的值可以指定域名地址，也可以有以下（不限，部分项没列举出来，只是常用项）几种关键字：

| name          | desc                     |
| ------------- | ------------------------ |
| none          | 不执行任何匹配           |
| self          | 与当前来源（非子域）匹配 |
| unsafe-inline | 允许内联 `js` 和 `css`   |
| unsafe-eval   | 允许执行 `eval` 等命令   |

如果设置了 `unsafe-inline` 或 `unsafe-eval`，需要做进一步的处理。由于 CSP 可以明确规定哪些为浏览器可接受的资源集，如果是采用 XSS 攻击（内联脚本），这是无法处理的。如果要使用的话，需要使用一个加密随机数（仅使用一次）或一个哈希值将指定脚本列入白名单

```html
<!-- 生成加密随机数 -->
<script nonce="EDNnf03nceIOfn39fn3e9h3sdfa"></script>
Content-Security-Policy: script-src 'nonce-EDNnf03nceIOfn39fn3e9h3sdfa'

<!-- 计算脚本自身的SHA哈希值并插入到script-src指令中 -->
Content-Security-Policy: script-src 'sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng='
<!-- 或者 -->
```

相关文档：[网络基础 🚀](https://developers.google.com/web/fundamentals/security/csp?hl=zh-cn)

<!-- Referrer-Policy -->

## 2021 年 12 月 8 日

### Mixed Contents

混合内容（`mixed contents`）：当 `https` 页面包含有 `http` 的内容时，即为 `mixed-contents`。这种页面部分加密，部分未加密，容易受到攻击

从 `Chrome 79` 开始，`Chrome` 将逐渐转向默认阻止所有混合内容，并且会自动将混合资源升级到 `https://`

可以通过 `CSP` 配置相关指令（取值目前就找到一个...）：

```html
<meta http-equiv="Content-Security-Policy" content="block-all-mixed-content" />
```

谷歌日志文档：<https://blog.chromium.org/2019/10/no-more-mixed-messages-about-https.html>

## 2021 年 12 月 9 日

### Referrer-Policy

这里的 `Referrer-Policy` 是指 `http` 响应头的参数，其用来监管哪些访问来源信息会在 `referrer` 中发送（可以理解为 `A` 页面跳转到 `B` 页面时所包含的 `A` 的来源信息，可以通过 `document.referrer` 获取）。主要有以下几种情况：

| 值                                    | 描述                                   |
| ------------------------------------- | -------------------------------------- |
| no-referrer                           | 不会发送                               |
| no-referrer-when-downgrade（default） | 同安全级别下会发送（https=>https）     |
| origin                                | 仅发送域名                             |
| origin-when-cross-origin              | 同源下发送完整的 URL，否则仅发送域名   |
| same-origin                           | 同源下发送                             |
| strict-origin                         | 同安全级别下发送域名                   |
| strict-origin-when-cross-origin       | 同源下发送完整 url，同安全级别发送域名 |
| unsafe-url                            | 发送完整 url                           |

可通过 `meta` 标签进行设置。

```html
<meta name="referrer" content="no-referrer" />
```

测试发现：修改了 `Referrer-Policy` 后，`js`、`css` 等资源都更改成对应值，但对 `index.html`（`localhost`）这个文件却不一定，其他如：部分图片、字体文件等也不一定会跟随改变。具体原因暂未查明

<!-- TODO: 查一下为什么有些资源不会跟随改变referrer-policy值 -->

> TIPS：这部分内容跟 referrer、CSP 等内容挺相关的，可以结合一起看看会更好一些（可直接搜索）

参考文档：

- <https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy>
- <https://segmentfault.com/a/1190000022101053?utm_source=sf-similar-article>
- <https://segmentfault.com/a/1190000017896469>

## 2021 年 12 月 10 日

### Cannot read property 'tapPromise' of undefined

这里是指使用 `compression-webpack-plugin` 时遇到 `Cannot read property 'tapPromise' of undefined` 异常的问题及解决方案

出现这个异常的问题是由于 `webpack` 版本导致。最新版的插件仅适用于 `webpack5`，而对于 `webpack4` 已经不支持。因此需要降低 `compression-webpack-plugin` 插件的版本。

经测试 `6.1.1` 版本可满足 webpack4 的需求，同时也是下载次数较多的一个版本
