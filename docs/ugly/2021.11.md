# 笔记

## 2021 年 11 月 1 日

缺席...

## 2021 年 11 月 2 日

缺席...

## 2021 年 11 月 3 日

缺席...

## 2021 年 11 月 4 日

缺席...

## 2021 年 11 月 5 日

缺席...

## 2021 年 11 月 6 日

缺席...

## 2021 年 11 月 7 日

缺席...

## 2021 年 11 月 8 日

### 首屏时间优化--视频

技术要点：

- 视频资源压缩（小丸工具箱，可移除音频）
- 视频资源格式转换为 `flv` 格式（借助 `B` 站开源的 `flv.js`）
- 其他非首屏资源延后加载

完整文档：[首屏视频的优化过程 🚀](https://segmentfault.com/a/1190000021578572)

### 首屏时间&白屏时间

- **白屏时间**：从页面打开到出现内容时的时间。浏览器只有加载并解析完头部资源才会真正渲染页面，因此可以通过获取头部资源加载完的时刻来近似（粗略）统计白屏时间

- **首屏时间**：首屏时间需要考虑各种情况如：图片、`iframe`、`video` 等。仅文本时，首屏时间即为 `DOMContentLoaded` 时间

#### performance API

重点关注 `performance API`，其中包含有：`memory`、`navigation`、`timeOrigin`、`timing` 四个属性。几乎都可以从这个 `API` 中拿到相关数值

分享个网上搜罗的好东西：

```javascript
// 出处：https://juejin.cn/post/6928739992986615816
window.onload = function() {
  var timing = performance.timing
  console.log("准备新页面时间耗时: " + timing.fetchStart - timing.navigationStart)
  console.log("redirect 重定向耗时: " + timing.redirectEnd - timing.redirectStart)
  console.log("Appcache 耗时: " + timing.domainLookupStart - timing.fetchStart)
  console.log("unload 前文档耗时: " + timing.unloadEventEnd - timing.unloadEventStart)
  console.log("DNS 查询耗时: " + timing.domainLookupEnd - timing.domainLookupStart)
  console.log("TCP连接耗时: " + timing.connectEnd - timing.connectStart)
  console.log("request请求耗时: " + timing.responseEnd - timing.requestStart)
  console.log("白屏时间: " + timing.responseStart - timing.navigationStart)
  console.log("请求完毕至DOM加载: " + timing.domInteractive - timing.responseEnd)
  console.log("解释dom树耗时: " + timing.domComplete - timing.domInteractive)
  console.log("从开始至load总耗时: " + timing.loadEventEnd - timing.navigationStart)
}
```

另外，获取首屏时间可以用 `performance.getEntries()` 获取 `first-contentful-paint` 的时间

#### 手打（网参）代码

白屏时间：

```html
<!-- 代码来源：https://fex.baidu.com/blog/2014/05/build-performance-monitor-in-7-days/ -->
<html>
  <head>
    <meta charset="UTF-8" />
    <script>
      //测试时间起点，实际统计起点为 DNS 查询，即navigationStart时间
      var start_time = +new Date()
    </script>
    <!-- 3s 后这个 js 才会返回 -->
    <script src="script.php"></script>
    <script>
      var end_time = +new Date() //时间终点
      var headtime = end_time - start_time //头部资源加载时间
      console.log(headtime)
    </script>
  </head>
  <body>
    <p>在头部资源加载完之前页面将是白屏</p>
    <p>script.php 被模拟设置 3s 后返回，head 底部内嵌 JS 等待前面 js 返回后才执行</p>
    <p>script.php 替换成一个执行长时间循环的 js 效果也一样</p>
  </body>
</html>
```

首屏时间：

```javascript
// 自己用的谷歌，没有那么严谨，不能直接用navigationStart作为开始时间哈
// 这里应该在head标签开始时插入一个获取时间戳的代码
let max = 0
let imgs = Array.from(document.getElementsByTagName("img")) // 获取所有的图片资源
imgs.forEach(tag => {
  tag.onload = function() {
    // 监听每一个图片的onload事件
    imgLoad(tag, tag.classList[0])
  }
})
function imgLoad(target, name) {
  // name没啥用，测试的时候拿来当名字用了
  target.dataset.time = new Date().getTime()
  console.log(name + "加载时间：" + (new Date().getTime() - performance.timing.navigationStart))
  let io = new IntersectionObserver(entries => {
    if (entries[0].intersectionRatio > 0) {
      // 过滤非首屏的图片
      max = Math.max(max, new Date().getTime())
      console.log(max)
    }
    io.unobserve(target)
  })
  io.observe(target)
}
```

<!-- TODO:  -->

疑问：

- video 视频是否会影响到首屏时间？

## 2021 年 11 月 9 日

### telepot

控制某个 `HTML` 模块（组件）挂载到指定的 `DOM` 下。使用方式如下，也可以通过 `id` 指定挂载的 `DOM`（`to="#target"`）。但需要注意，挂载的位置不会影响到原先的父子结构，即不会影响父组件的数据注入

如果有多个 `teleport` 挂载到同一个目标下，`teleport` 将会按照先后顺序插入到目标 `DOM` 下（感觉层级比较乱或出现问题的情况下会用的比较多吧，另外其实跟 `element ui` 的 `modal-append-to-body` 的效果差不多，不过 `teleport` 可以指定挂载的 `DOM`）

```HTML
<teleport to="body">
  <div>
      <h2>teleport</h2>
  </div>
</teleport>
```

## 2021 年 11 月 10 日

### 全局引入方式

#### 全局变量

`vue3` 中 `vue.property` 已被替换成 `config.globalProperties`。由于 `composition API` 中的 `this` 已经不是我们 `vue2` 中认识的 `this`，因此我们需要通过 `getCurrentInstance()` 方法来获取到当前实例

此时访问全局变量的方式则变成：

```javascript
// main.js
const app = createApp({})
app.config.globalProperties.$http = () => {}

// home.vue
setup() {
  const { $http } = getCurrentInstance().appContext.config.globalProperties
}

```

尽管作为 `vue.property` 的一种替代方案，但 `vue3` 官方文档仍建议用 `provide` 替代 `globalProperties`

```javascript
// main.js
app.provide('guide', 'Vue 3 Guide')

// home.vue
setup() {
  console.log(inject('guide'))
}
// Warning：inject() can only be used inside setup() or functional components.
```

#### 指令、组件、插件等

这里以 component 组件为例（其他类似）

```javascript
// /testComp/index.js
// install方法同vue2
import comp from "./index.vue"
export default {
  install: app => {
    app.component("testComp", comp)
  }
}

// main.js
// 需要use一下
import testComp from "./components/testComp"
const app = createApp(App)
app.use(testComp)
```

## 2021 年 11 月 11 日

### 我想不到系列之 -- 图片的优化

给图片加上 width、height 属性有利于 CLS（Cumulative Layout Shift 累积布局偏移）优化，通俗一点来说就是可以减少页面的重绘和回流

为什么可以减少页面重绘和回流？在设置了 width、height 属性之后，浏览器会根据图像的宽高属性设置图像的默认宽高比，因此开发者只要设置了宽高其中一个的数值时，浏览器便能计算出另外一个的数值

```html
<!-- 注意是不带单位的width、height值 -->
<img src="xxx.png" width="300" height="150" />
```

```css
/* 在谷歌img会多了这么一个默认属性： */
img[Attributes Style] {
  width: 313px;
  aspect-ratio: auto 313 / 428;
  height: 428px;
}
```

参考文档：[优化 Cumulative Layout Shift 累积布局偏移 🚀](https://web.dev/optimize-cls/?utm_source=lighthouse&utm_medium=devtools#images-without-dimensions)

## 2021 年 11 月 12 日

### Event Bus

`vue3` 中已废除 `$on`、`$off`、`$once` 实例方法，不能再像 `vue2` 一样使用。但 `vue3` 也提供了替换的方法：[mitt](https://github.com/developit/mitt)、[tiny-emitter](https://github.com/scottcorgan/tiny-emitter)

建议少用...

```javascript
// tiny-emitter使用如下：
import Emitter from "tiny-emitter"
const emitter = new Emitter()
// 绑定为全局可用或provide全局注入
app.config.globalProperties.emitter = emitter

// 触发与监听事件
// emitter.on('some-event', function (arg1, arg2, arg3) {})
// emitter.emit('some-event', 'arg1 value', 'arg2 value', 'arg3 value')
```

### $attrs、$listeners

`vue3` 中已经废除了 `$listeners`，在 `vue3` 的虚拟 `DOM` 中，事件监听器现在只是以 `on` 为前缀的 `attribute`，这样它就成为了 `$attrs` 对象的一部分，且可以通过 context.attrs[target] 访问

```html
<template>
  <label>
    <input type="text" v-bind="$attrs" />
  </label>
</template>
```

## 2021 年 11 月 13 日

缺席...

## 2021 年 11 月 14 日

缺席...

## 2021 年 11 月 15 日
